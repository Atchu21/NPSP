public with sharing class DRS_ContactMerge_CTRL {
      
    

    private static final String MASTER_KEY = '$MASTER$';

    /*******************************************************************************************************
    * @description To decide whether to show Dupliacate Record Set record list on the page or not
    */ 
    
    public Boolean showDRS { get; set; }
    
    /*******************************************************************************************************
    * @description The contact merge step user is in. (The process has multiple steps.)
    */
    public Integer step { get; private set; }
    
    /*******************************************************************************************************
    * @description Duplicate Record Sets to be displayed on page
    */ 
    public List<DuplicateRecordSet> listDuplicateRecordSets { get; set; }
    
    /*******************************************************************************************************
    * @description List of ContactWrapper objects for display in search results pane.
    */
    public List<ContactWrapper> contactResults { get; private set; }

    /*******************************************************************************************************
     * @description To store the selected DRS recordId 
     */
    public String DRSrecordId { get; set; }

    /*******************************************************************************************************
     * @description The rows to merge.
     */ 
    public List<FieldRow> fieldRows { get; set; }
    
    /*******************************************************************************************************
     * @description Map of the contacts selected for merge.
     */ 
    private Map<String, Contact> selectedRecords;
    
    /*******************************************************************************************************
    * @description Number of selected records.
    */
    public Integer selectedRecordsCount { get; private set; } {this.selectedRecordsCount = 0;}

    /*******************************************************************************************************
    * @description Standard set controller variables
    */ 
    public ApexPages.StandardSetController stdSetCon {
       get {
           if(stdSetCon == null){ 
               stdSetCon = new ApexPages.StandardSetController(Database.getQueryLocator(constructDRSSOQL())); 
               stdSetCon.setPageSize(pageSize);    
           }
           return stdSetCon;
       }
       set;
    }
    
    /*******************************************************************************************************
    * @description The list of Duplicate Record Set field names that are used in search and displayed in Found Duplicate
    * Record Sets.
    */
    private List<String> drsFieldNames {
        get {
            if (drsFieldNames == null) {
                drsFieldNames = UTIL_Describe.listStrFromFieldSet
                                      ('DuplicateRecordSet', 
                                      UTIL_Namespace.StrTokenNSPrefix('ContactMergeDRS'));
                Set<String> setStr = new set<string>(drsfieldNames);
                // now add additional fields we know we need
                setStr.add('Id');
                setStr.add('Name');
                setStr.add('DuplicateRuleId');
                setStr.add('RecordCount');
                setStr.add('LastModifiedDate');
                drsFieldNames.clear();
                drsFieldNames.addAll(setStr);
            }
            return drsFieldNames;
        }
        set;
    }
    
    /*******************************************************************************************************
    * @description The list of Duplicate Record Item field name to be displayed in Found Duplicate Record Sets.
    */
    private List<String> driFieldNames {
        get {
            if (driFieldNames == null) {
                driFieldNames = new List<String>();
                driFieldNames.add('RecordId');
            }
            return driFieldNames;
        }
        set;
    }
    /*******************************************************************************************************
    * @description The list of contact field names that are used to display on page.
    */
    private list<string> listStrContactField {
        get {
            if (listStrContactField == null) {
                listStrContactField = UTIL_Describe.listStrFromFieldSet('Contact', UTIL_Namespace.StrTokenNSPrefix('ContactMergeFoundFS'));
                set<string> setStr = new set<string>(listStrContactField);
                // now add additional fields we know we need
                setStr.add('Id');
                setStr.add('Name');
                listStrContactField.clear();
                listStrContactField.addAll(setStr);
            }
            return listStrContactField;
        }
        set;
    }
    /*******************************************************************************************************
    * @description To decide whether to continue with Contact merge page depending on permissions for contact object
    */
    public Boolean canContinueWithMerge { get; set; }
    
    /*******************************************************************************************************
    * @description Check whether user has delete permission on Contact
    *@return Boolean Whether user has contact delete permission
    */

    public Boolean hasContactObjectDeletePermission() {
        return UTIL_Describe.getObjectDescribe('Contact').isDeletable();
    }
    
    
    /*******************************************************************************************************
    * @description To decide whether to continue with DRS display page depending on permissions for 
    * Duplicate Reccord Set object
    */
    public Boolean canContinueWithDRSDisplay { get; set; }
    
       
    /*******************************************************************************************************
    * @description Duplicate Record Set diplay page size.
    */
    private Integer pageSize = 10;
    
    /*******************************************************************************************************
    * @description Total number of pages in pagination implemented on Duplicate Record Set diplay page.
    */
    public Integer totalPages { get; set; }
    
    /*******************************************************************************************************
    * @description First Contact created for each DRS
    */
    public Map<Id,Contact> firstContactOfDRS { get; set; }

            
    /***************************************************************************************************
    * @description Checks whether there are more records to display on next page in pagination implemented 
    * on Duplicate Record Set diplay page.
    */
    
    public Boolean hasNext {
        get {
            return stdSetCon.getHasNext();
        }
        set;
    }
    
    /***************************************************************************************************
    * @description Checks whether there are records prior to the records dislayed on the current page to be 
    * display on the previous page in pagination implemented on Duplicate Record Set diplay page.
    */
    
    public Boolean hasPrevious {
        get {
            return stdSetCon.getHasPrevious();
        }
        set;
    }
    
    /***************************************************************************************************
    * @description Page number of the current page
    */
    
    public Integer pageNumber {
        get {
            return stdSetCon.getPageNumber();
            }
        set;
    } 

    /*******************************************************************************************************
    * @description The struct to save all the information belonging to each contact field, including values for
    * all the contacts to merge.
    */
    public class FieldRow {
        /*******************************************************************************************************
        * @description Stores the field Label.
        */
        public String fieldLabel { get; private set; }
        /*******************************************************************************************************
        * @description Stores the field api name.
        */
        public String fieldName { get; private set; }
        /*******************************************************************************************************
        * @description Property to tell whether UI must should a radio to select the field value.
        */
        public boolean showRadio { get; private set; }
        /*******************************************************************************************************
        * @description  List of values for each contact record.
        */
        public List<Cell> values { get; private set; }
        /*******************************************************************************************************
        * @description Selected record.
        */
        public String selectedValue { get; set; }
        /*******************************************************************************************************
        * @description The class style.
        */
        public String styleClass { get; private set; }

        /*******************************************************************************************************
        * @description Constructor that initializes the values property.
        */
        public FieldRow() {
            this.values = new List<Cell>();
        }

        /*******************************************************************************************************
        * @description Constructor that initializes the values property.
        * @param fieldName The name of the field.
        * @param fieldLabel The field label.
        * @param showRadio Wether a radio button should be displayed for the row.
        * @param styleClass The style class.
        */
        public FieldRow(String fieldName, String fieldLabel, boolean showRadio, String styleClass) {
            this();
            this.fieldName = fieldName;
            this.fieldLabel = fieldLabel;
            this.showRadio = showRadio;
            this.styleClass = styleClass;
        }
    }

    /*******************************************************************************************************
    * @description The cell for a corresponding field row in the UI table.
    */
    public class Cell {
        /*******************************************************************************************************
        * @description Id of the record to which this value belongs.
        */
        public String objId { get; private set; }
        /*******************************************************************************************************
        * @description The actual value.
        */
        public String value { get; private set; }

        /*******************************************************************************************************
        * @description Constructor that sets instance properties.
        * @param objectId The ID of the object whose field represented by the cell.
        * @param value The value of the field represented by the cell.
        */
        public Cell(String objectId, String value) {
            this.objId = objectId;
            this.value = value;
        }
    }
      
    /*******************************************************************************************************
    * @description Constructor for StandardSetController to allow invocation from list views.
    * @param controller The default list controller for Duplicate Record Sets. It allows us to do pagination on the page.
    */
    public DRS_ContactMerge_CTRL (ApexPages.StandardSetController controller) {
        showDRS = false;
        totalPages  = 0;
        canContinueWithMerge = true;
        canContinueWithDRSDisplay = true;
        listDuplicateRecordSets = new List<DuplicateRecordSet>();
        contactResults = new List<ContactWrapper>();
        step = 1;
        fieldRows = new List<FieldRow>();
        selectedRecords = new Map<String, Contact>();
        firstContactOfDRS = new Map<Id,Contact>();
        // Check if user has delete permission on Contact
        if (!hasContactObjectDeletePermission()) {
            canContinueWithMerge = false;
            ApexPages.addMessage(new ApexPages.Message(ApexPages.Severity.ERROR, System.Label.conMergeErrorNoDeleteObjPermission));
            return;
        }
        
    }

    /*******************************************************************************************************
    * @description returns whether the field should be treated as an NPSP read only field, typically one
    * of our rollup fields that get automatically populated by rollups, and users should not direclty modify.
    * @return boolean true if should be treated as readonly, false if not.
    */
    private Boolean isNPSPReadOnly(String strField) {
        // we have to maintain our own set of readonly fields, because
        // RLLP_OppRollup_UTIL.ContactFields doesn't include them all!
        List<String> listStrField = new List<String>{
            'npo02__TotalOppAmount__c',
            'npo02__AverageAmount__c',
            'npo02__SmallestAmount__c',
            'npo02__LargestAmount__c',
            'npo02__FirstCloseDate__c',
            'npo02__LastCloseDate__c',
            'npo02__NumberOfClosedOpps__c',
            'npo02__OppAmountThisYear__c',
            'npo02__OppsClosedThisYear__c',
            'npo02__OppAmountLastYear__c',
            'npo02__OppsClosedLastYear__c',
            'npo02__OppsClosed2YearsAgo__c',
            'npo02__OppAmount2YearsAgo__c',
            'npo02__OppsClosedLastNDays__c',
            'npo02__OppAmountLastNDays__c',
            'npo02__TotalMembershipOppAmount__c',
            'npo02__NumberOfMembershipOpps__c',
            'npo02__LastMembershipDate__c',
            'npo02__LastMembershipAmount__c',
            'npo02__LastMembershipLevel__c',
            'npo02__LastMembershipOrigin__c',
            'npo02__MembershipJoinDate__c',
            'npo02__MembershipEndDate__c',
            'npo02__LastOppAmount__c',
            'npo02__Best_Gift_Year__c',
            'npo02__Best_Gift_Year_Total__c',
            'Soft_Credit_Last_N_Days__c',
            'npo02__Soft_Credit_Last_Year__c',
            'npo02__Soft_Credit_This_Year__c',
            'npo02__Soft_Credit_Total__c',
            'npo02__Soft_Credit_Two_Years_Ago__c',
            'First_Soft_Credit_Amount__c',
            'First_Soft_Credit_Date__c',
            'Largest_Soft_Credit_Amount__c',
            'Largest_Soft_Credit_Date__c',
            'Last_Soft_Credit_Amount__c',
            'Last_Soft_Credit_Date__c',
            'Number_of_Soft_Credits__c',
            'Number_of_Soft_Credits_Last_N_Days__c',
            'Number_of_Soft_Credits_Last_Year__c',
            'Number_of_Soft_Credits_This_Year__c',
            'Number_of_Soft_Credits_Two_Years_Ago__c'
        };

        for (String strF : listStrField) {
           if (strField.equalsIgnoreCase(strF))
               return true;
        }
        return false;
    }

    /*******************************************************************************************************
    * @description returns whether the field should be treated as an NPSP hidden field, typically one
    * of our deprecated or system fields
    * @return boolean true if should be treated as hidden, false if not.
    */
    private boolean isNPSPHiddenField(string strField) {
        list<string> listStrField = new list<string>{
            'npe01__SystemAccountProcessor__c',
            'npo02__SystemHouseholdProcessor__c',
            'npe01__SystemIsIndividual__c',
            'Current_Address__c'
        };

        for (string strF : listStrField) {
           if (strField.equalsIgnoreCase(strF))
               return true;
        }
        return false;
    }
    /*******************************************************************************************************
    * @description Returns a referenced object's name field.
    * @param controller The default list controller for contact. It allows us to do pagination on the page.
    * @return string The name of the name field, or null if we couldn't find one.
    */
    private string getRelatedObjNameField(Schema.DescribeFieldResult fieldDesc) {
        string nameField = 'Name';
        Map<String, Schema.SObjectField> mapRelatedObjectFields = fieldDesc.getReferenceTo()[0].getDescribe().fields.getMap();

        //if Name isn't the correct name field, find it
        if (!mapRelatedObjectFields.containsKey(nameField)) {
            nameField = null;
            for (String relatedFieldName : mapRelatedObjectFields.keySet()) {
                if (mapRelatedObjectFields.get(relatedFieldName).getDescribe().isNameField())
                    return relatedFieldName;
            }
        }
        return nameField;
    }

    /*******************************************************************************************************
    * @description checks if the logged in user have delete permission for the selected records.
    * @param ContactIds list of contacts
    * @return boolean.  true if delete access is allowed.
    ********************************************************************************************************/
    private boolean canUserDeleteSelectedContacts(Set<Id> contactIds) {
        List <UserRecordAccess> userAccess = [
             SELECT RecordId, HasEditAccess, HasDeleteAccess, MaxAccessLevel
             FROM UserRecordAccess
             WHERE UserId = :UserInfo.getUserId()
             And RecordId IN :contactIds
        ];
        for (UserRecordAccess user: userAccess) {
            if (!user.HasDeleteAccess ) {
                return false;
            }
        }
        return true;
    }

    /*******************************************************************************************************
    * @description Adds field information and field values to the list of field rows.
    */
    private void addFieldComparisonRows(String fieldName, Schema.DescribeFieldResult fieldDesc, List<SObject> objs) {
        // Create a new FieldRow item
        FieldRow row = new FieldRow();
        row.fieldName = fieldName;

        // For standrd lookup type fields, use the relationship name as the field label
        if (!fieldDesc.isCustom() && fieldDesc.getRelationshipName() != null) {
            row.fieldLabel = fieldDesc.getRelationshipName();
        } else {
            row.fieldLabel = fieldDesc.getLabel();
        }

        row.values = new List<Cell>();

        boolean isDifferent = false; // flag to indicate whether atleast one pair of field values is different across all contacts
        boolean isNull = true; // flag to indicate whether all the field values are null
        Integer idx = 0;

        List<String> values = new List<String>();
        DateTime lastModifiedDate = null;
        String prev;

        // Iterate over all contacts to find the field values and add them to row values
        for (SObject c : objs) {
            // For lookup fields set the name as the values
            if (fieldDesc.getRelationshipName() != null) {
                Sobject obj = c.getSObject(fieldDesc.getRelationshipName());
                if (obj != null) {
                    values.add(String.valueOf(obj.get(getRelatedObjNameField(fieldDesc))));
                } else {
                    values.add(null);
                }
            } else {
                values.add(String.valueOf(c.get(fieldName)));
            }

            isNull &= (c.get(fieldName) == null); // Check if the value is null

            if (idx == 0) {
                prev = String.valueOf(c.get(fieldName));
            }
            if (idx > 0 && !isNull) {
                // Check if atleast one of the values is different. If yes then update the isDifferent flag
                String current = String.valueOf(c.get(fieldName));
                if ((prev != null && !prev.equals(current)) ||
                    (current != null && !current.equals(prev))) {
                    isDifferent = true;
                }
                prev = current;
            }

            // Select the default value for the field. A non-null value on the latest modified record
            if (c.get(fieldName) != null && (lastModifiedDate == null ||
                (lastModifiedDate != null && (DateTime)c.get('lastModifiedDate') > lastModifiedDate))) {
                row.selectedValue = c.id;
                lastModifiedDate = (DateTime)c.get('lastModifiedDate');
            }

            idx++;
        }

        // If atleast one record has a non-null field value, then add it to the list of fieldRows.
        if (!isNull) {
            for (Integer i=0; i < values.size(); i++) {
                String val = values[i];
                if (val != null && val.length() > 255) {
                    val = val.substring(0, 251) + ' ...';
                }
                row.values.add(new Cell(objs[i].id, val));
            }
            // Show the select radio only if the field values are different.
            // Dont let user choose the account as you dont want users to assign a differnt account in One to One case.
            row.showRadio = (isDifferent && !fieldName.equalsIgnoreCase('accountId') && !isNPSPReadOnly(fieldName));
            fieldRows.add(row);
        }
    }

    /*******************************************************************************************************
    * @description Redirects to the NPSP Contact Merge page
    * @return PageReference The page that it redirects to CON_ContactMerge page.
    */
    public PageReference searchByContact() {
        try {
            PageReference pageRef = new PageReference('/apex/CON_ContactMerge');
            pageRef.getParameters().put('showContactSearch','true');
            pageRef.setRedirect(true);
            return pageRef;
                  
        } catch (exception ex) {
            ApexPages.addMessage(new ApexPages.Message(ApexPages.Severity.Error, ex.getMessage()));
        }
        return null;
    }
    
    /******************************************************************************************************
     * @description Fetches the list of Duplicate Record Sets from standard set controller for pagination
     * @return List<DuplicateRecordSet> Returns the current list of Duplicate Record Sets
     */
    public List<DuplicateRecordSet> getDuplicateRecordSets() {
        return (List<DuplicateRecordSet>)stdSetCon.getRecords();
    }
    
    /*******************************************************************************************************
    * @description Shows list of Duplicate Record Set records related to contact dupliacte rules
    */
    public void showDuplicateRecordSets() {
        Try {
            showDRS = true;
            listDuplicateRecordSets = getDuplicateRecordSets();
            driFieldNames.add('DuplicateRecordSetId');
            List<DuplicateRecordSet> duplicateRecordSets = new List<DuplicateRecordSet>((List<DuplicateRecordSet>)Database.query(constructDRSSOQL()));
            driFieldNames.remove(driFieldNames.indexOf('DuplicateRecordSetId'));
            //Fetch the ids of all Duplicate Record Items
            Set<Id> allDRIIds = new Set<Id>();
            List<DuplicateRecordItem> allDRIs = new List<DuplicateRecordItem>();
            for(DuplicateRecordSet dupRecSet : duplicateRecordSets) {
                allDRIIds.addAll(new Map<Id, DuplicateRecordItem>(dupRecSet.DuplicateRecordItems).keySet());
                allDRIs.addAll(new Map<Id, DuplicateRecordItem>(dupRecSet.DuplicateRecordItems).values());
            }
            // Construct query to fetch all the related contact records to find the first contact related to the DRS record
            Integer queryLimit = 30000;
            List<String> contactField = new List<String>();
            contactField.add('Id');
            contactField.add('Name');
            contactField.add('createdDate');
             
            String whereString = new UTIL_Query()
                .withFrom('DuplicateRecordItem')
                .withSelectFields(driFieldNames)
                .withWhere('Id IN :allDRIIds')
                .build();
            whereString = 'Id IN (' + whereString + ')'; 
            String contactQueryStr =  new UTIL_Query()
                .withFrom('Contact')
                .withSelectFields(contactField)
                .withWhere(whereString)
                .withLimit(queryLimit)
                .build();
            Map<Id,Contact> contacts = new Map<Id,Contact>((List<Contact>)Database.query(contactQueryStr));
            for(DuplicateRecordItem dri : allDRIs) {
                Contact con = contacts.get(dri.RecordId);
                if(!(firstContactOfDRS.containsKey(dri.DuplicateRecordSetId))) {
                    firstContactOfDRS.put(dri.DuplicateRecordSetId,con);
                }
                else {
                    if(con.createdDate < firstContactOfDRS.get(dri.DuplicateRecordSetId).createdDate) {
                        firstContactOfDRS.put(dri.DuplicateRecordSetId,con);
                    }
                }
            }
            totalPages = getTotalPages(); 
        } catch (exception ex) {
                ApexPages.addMessage(new ApexPages.Message(ApexPages.Severity.Error, ex.getMessage()));
        }
    }
    
    /*******************************************************************************************************
    * @description Construct SOQL query to fetch all the contact related Duplicate Record Sets
    * @return String Returns the query to fetch Duplicate Record Sets
    */
    public String constructDRSSOQL() {
        //build SOQL subquery on Duplicate Record Items
        String subQueryOrderBy = 'CreatedDate ASC';
        
        String subQuery =  new UTIL_Query()
            .withFrom('DuplicateRecordItems')
            .withSelectFields(driFieldNames)                                  
            .build();
        String subQueryStr = '('+subQuery+')';
        drsFieldNames.add(subQueryStr);
        String setOrderBy = 'LastModifiedDate DESC ';
        String setWhereClause = 'RecordCount > 1 AND DuplicateRule.SObjectType = \'Contact\'';
        Integer soqlLimit = 7000;
        //build the SOQL query and execute
        String queryStr =  new UTIL_Query()
            .withFrom(DuplicateRecordSet.sObjectType)
            .withSelectFields(drsFieldNames)
            .withWhere(setWhereClause)
            .withOrderBy(setOrderBy)
            .withLimit(soqlLimit)
            .build();
        drsFieldNames.remove(drsFieldNames.indexOf(subQueryStr));
        return queryStr;
    }
    
    /*******************************************************************************************************
    * @description Shows list of Contact records related to selected Duplicate Record Set
    */
    public PageReference showContactRelatedToDRS() {
        //logic to display contacts related to selected DRS
        Try {
            step = 2;
            this.contactResults = wrapSOQLResults(queryRecords());
        } catch (exception ex) {
            ApexPages.addMessage(new ApexPages.Message(ApexPages.Severity.Error, ex.getMessage()));
        }
        return null;
    }

    /******************************************************************************************************
    * @description This will query the duplicate contacts related to the DRS which is picked
    * @return the list of contacts
    */
    public list<SObject> queryRecords() {
        contactResults.clear();
        String whereString = new UTIL_Query()
            .withFrom('DuplicateRecordItem')
            .withSelectFields(driFieldNames)
            .withWhere('DuplicateRecordSetId =:DRSrecordId')
            .build();
        whereString = 'Id IN ('+ whereString + ')';
        String queryString = new UTIL_Query()
            .withFrom('Contact')
            .withSelectFields(listStrContactField)
            .withWhere(whereString)
            .build();
        return Database.query(queryString);
    }

    /*******************************************************************************************************
    * @description Wraps the SOQL results.
    * @param contactResults The list of SObjects to wrap.
    * @return List<ContactWrapper> Those records from the passed parameter that are of type Contact are returned
    * in this list, inside wrappers.
    */
    public List<ContactWrapper> wrapSOQLResults(List<SObject> contactResults) {
        List<ContactWrapper> res = new List<ContactWrapper>();
        for (SObject returnedObject : contactResults) {
            ContactWrapper thisResult = new ContactWrapper((Contact) returnedObject);
            res.add(thisResult);
        }
        return res;
    }
    /*******************************************************************************************************
    * @description Shows the next step of the wizard where user can see the diff of the records before merge.
    */
    public void nextStep() {

        set<Id> mergeIds = new set<Id>();
        for (ContactWrapper contactWrap : contactResults) {
            if (contactWrap.selected) {
                mergeIds.add(contactWrap.contactRecord.Id);
            }
        }
        loadMergeCandidates(mergeIds);
    }
    /*******************************************************************************************************
    * @description Shows the next step of the wizard where user can see the diff of the records before merge.
    */
    private void loadMergeCandidates(set<Id> mergeCandidates) {

        // Check we have atleast 2 and not more than 3 records selected for merge. If not throw an error.
        if (mergeCandidates.size() <=1) {
            ApexPages.addMessage(new ApexPages.Message(ApexPages.Severity.Error, Label.npe01.Contact_Merge_Error_Too_Few_Contacts));
            return;
        }

        if (mergeCandidates.size() >3 ) {
            ApexPages.addMessage(new ApexPages.Message(ApexPages.Severity.Error, Label.npe01.Contact_Merge_Error_Too_Many_Contacts));
            return;
        }

        selectedRecordsCount = mergeCandidates.size();

        Map<String, Schema.SObjectField> contactFields = Schema.SObjectType.Contact.fields.getMap();
        Map<String, Schema.DescribeFieldResult> standardFieldMap = new Map<String, Schema.DescribeFieldResult>();
        Map<String, Schema.DescribeFieldResult> customFieldMap = new Map<String, Schema.DescribeFieldResult>();

        // Construct the query string
        String query = 'Select id, name, ';
        for (String fieldName : contactFields.keySet()) {
            Schema.SobjectField f = contactFields.get(fieldName);
            Schema.DescribeFieldResult fResult = f.getDescribe();

            // Ignore fields that have an identical API name as an npsp prefixed field
            // This is due to a bug in dynamic SOQL, quich causes querying for two real fields,
            // e.g. npsp__foo__c and foo__c, to throw a duplicate field selected error.
            // Only select the NPSP namespaced field and ignore the same field without namespace
            if (!String.isBlank(UTIL_Namespace.getNamespace()) && !fieldName.startsWith(UTIL_Namespace.getNamespace()+'__') &&
                contactFields.containsKey(UTIL_Namespace.StrTokenNSPrefix(fieldName))) {

                continue;
            }

            // Only include the fields which are updateable and accessible
            if (fResult.isUpdateable() && fResult.isAccessible() && !isNPSPHiddenField(fieldname)) {
                // If the field is type lookup, select the parent name
                string relName = fResult.getRelationshipName();
                if (string.isBlank(relName)) {
                    query += (fieldName + ',');
                } else {
                    //find the Name field for the related object
                    string nameField = getRelatedObjNameField(fResult);

                    if (nameField!=null) {
                        query += (relName + '.' + nameField + ',');
                    }
                }
                // Collect the standard and custom fields separately for sorting
                if(fResult.isCustom()) {
                    customFieldMap.put(fieldName, fResult);
                } else {
                    standardFieldMap.put(fieldName, fResult);
                }
            }
        }
        // Adding some non-updateable system fields which we need to add to the record diff table.
        query +=  'createdby.name, createddate, LastModifiedBy.name, LastModifiedDate';
        // Finally completing the query by appending the table name and the filter clause
        query += ' from Contact where id IN :mergeCandidates';

        //UTIL_Debug.debug('The contact query is: ' + query);

        List<Contact> contacts;
        try {
            contacts = Database.query(query); // Query the records
            // Ensure we got back the same number of records as expected. In case any record got deleted/moved since last search.
            if (contacts == null || contacts.size() != mergeCandidates.size()) {
                ApexPages.addMessage(new ApexPages.Message(ApexPages.Severity.Error, Label.npe01.Contact_Merge_Error_Query_Failed + ' ' + Label.npe01.Contact_Merge_Error_please_retry));
                return;
            }
        } catch (Exception e) {
            ApexPages.addMessage(new ApexPages.Message(ApexPages.Severity.Error, Label.npe01.Contact_Merge_Error_Contact_not_found + ' Error: ' + e));
            return;
        }

        if (!canUserDeleteSelectedContacts(mergeCandidates)) {
            ApexPages.addMessage(new ApexPages.Message(ApexPages.Severity.Error, System.Label.conMergeErrorNoDeleteRecAccess));
            return;
        }

        // Update the list of searched records with only the ones selected
        contactResults.clear();
        for (Contact c : contacts) {
            this.selectedRecords.put(c.id, c);
        }

        // Sort the standard fields list by name before creating the list of FieldRow for merge UI
        List<String> standardFieldList = new List<String>();
        standardFieldList.addAll(standardFieldMap.keySet());
        standardFieldList.sort();

        // Sort the custom fields list by name before creating the list of FieldRow for merge UI
        List<String> customFieldList = new List<String>();
        customFieldList.addAll(customFieldMap.keySet());
        customFieldList.sort();

        // Add the first row of type header with contact names as titles
        FieldRow temp = new FieldRow('', '', false, 'header');
        for (Sobject c: contacts) {
            Contact con = (Contact) c;
            temp.values.add(new Cell(c.id, con.name));
        }
        fieldRows.add(temp);

        // Add second row to select the master record. Select the one which is last modified
        temp = new FieldRow(MASTER_KEY, 'Master Record', true, null);
        {
            DateTime lastModifiedDate;
            for (Sobject c: contacts) {
                temp.values.add(new Cell(c.id, null));
                if (lastModifiedDate == null ||
                    (lastModifiedDate != null && (DateTime)c.get('lastModifiedDate') > lastModifiedDate)) {
                    temp.selectedValue = c.id;
                    lastModifiedDate = (DateTime)c.get('lastModifiedDate');
                }
            }
        }
        fieldRows.add(temp);

        // Add the portal row if any of the contacts have a user record
        List<User> portalUsers = new List<User>([SELECT Id, ContactId FROM User WHERE ContactId IN :contacts]);
        if (!portalUsers.isEmpty()) {
            Map<Id, Boolean> hasUserRecordByContactId = new Map<Id, Boolean>();
            for (User portalUser : portalUsers) {
                hasUserRecordByContactId.put(portalUser.ContactId, true);
            }
            temp = new FieldRow(System.Label.conMergePortalUser, System.Label.conMergePortalUser, false, null);
            for (Sobject c: contacts) {
                Contact con = (Contact) c;
                temp.values.add(new Cell(c.id, String.valueOf(hasUserRecordByContactId.containsKey(c.Id))));
            }
            fieldRows.add(temp);
        }

        // Add a dummy row to add a 'Standard Fields' header before the list of standard fields
        fieldRows.add(new FieldRow('Standard Fields', 'Standard Fields', false, 'separator'));

        // Add all standard fields to the list of FieldRow in sorted manner
        for (String fieldName: standardFieldList) {
            addFieldComparisonRows(fieldName, standardFieldMap.get(fieldName), contacts);
        }

        // Add a dummy row to add a 'Custom Fields' header before the list of custom fields
        fieldRows.add(new FieldRow('Custom Fields', 'Custom Fields', false, 'separator'));

        // Add all custom fields to the list of FieldRow in sorted manner
        for (String fieldName: customFieldList) {
            addFieldComparisonRows(fieldName, customFieldMap.get(fieldName), contacts);
        }

        // Add a dummy row to add a 'System Fields' header before the list of system fields
        fieldRows.add(new FieldRow('System Fields', 'System Fields', false, 'separator'));

        // Add created by and last modified by system fields to the list of FieldRow
        FieldRow createdByRow = new FieldRow('CreatedById', 'Created By', false, null),
            lastModifiedByRow = new FieldRow('LastModifiedById', 'Last Modified By', false, null);
        for (Sobject c: contacts) {
            SObject createdBy = c.getSObject('createdby');
            SObject modifiedBy = c.getSObject('lastModifiedBy');
            createdByRow.values.add(new Cell(c.id, (createdBy != null ? createdBy.get('name') : '') + ' ' + c.get('createdDate')));
            lastModifiedByRow.values.add(new Cell(c.id, (modifiedBy != null ? modifiedBy.get('name') : '') + ' ' + c.get('LastModifiedDate')));
        }
        fieldRows.add(createdByRow);
        fieldRows.add(lastModifiedByRow);

        // If everything looks good go to "choose winning contact" step
        this.step = 3;

    }

    /*******************************************************************************************************
    * @description Selects all the values of a certain record. Used by the "Select All" command link on the page.
    * @return void
    */
    public void selectDefaultRecord() {
        String recordId = Apexpages.currentPage().getParameters().get('recordId');
        //UTIL_Debug.debug('Selected Record: ' + recordId);
        if (recordId != null && selectedRecords.keySet().contains(recordId)) {
            for (FieldRow row : fieldRows) {
                if (row.showRadio) {
                    row.selectedValue = recordId;
                }
            }
        }
    }

    /*******************************************************************************************************
    * @description Merges the winner and losers.
    * @return PageReference The page that it redirects to. Same page user is in.
    */
    public PageReference mergeContacts() {
        SObject master;
        // Find the master record based the selected value of the Master FieldRow
        for (FieldRow row : fieldRows) {
            if (row.showRadio && row.fieldName.equals(MASTER_KEY)) {
                master = new Contact(id = row.selectedValue);
                break;
            }
        }

        if (master != null) {
            // Update the field values of master record based on the selected value for each field.
            for (FieldRow row : fieldRows) {
                if (row.showRadio && !row.fieldName.equals(MASTER_KEY) && row.selectedValue != master.id) {
                    SObject selectedRecord = this.selectedRecords.get(row.selectedValue);

                    // Sobject.put is not happy when sobject.get returns null. It throws an exception System.SObjectException: Illegal assignment from Object to String.
                    // But instead when you pass a null directly to put, it works fine. And hence, this if statement.
                    if (selectedRecord.get(row.fieldName) == null) {
                        master.put(row.fieldName, null);
                    } else {
                        Object val = selectedRecord.get(row.fieldName);
                        //UTIL_Debug.debug('Setting value: ' + val);
                        master.put(row.fieldName, val);
                        //UTIL_Debug.debug('Set value: ' + master.get(row.fieldName));
                    }
                }
            }

            // Group all the loosing records separately.
            List<Contact> losers = new List<Contact>();

            for (Contact c : this.selectedRecords.values()) {
                if (c.id != master.id) {
                    losers.add(c);
                }
            }

            // before proceeding further first lock the records for change
            List<Contact> allContacts = new List<Contact>();
            allContacts.add((Contact)master);
            allContacts.addAll(losers);
            List<Contact> lock = [Select id from Contact where id IN :allContacts for update];

            if (lock == null || lock.size() != allContacts.size()) {
                ApexPages.addMessage(new ApexPages.Message(ApexPages.Severity.Error, label.npe01.Contact_Merge_Error_Lock_failed  + ' ' + label.npe01.Contact_Merge_Error_please_retry) );
                return null;
            }

            System.SavePoint sp = Database.setSavepoint();
            try {
                Database.DMLOptions dml = new Database.DMLOptions();
                dml.DuplicateRuleHeader.AllowSave = true;
                // We need to turn off Affiliation processing or there will be duplicate affiliates created
                // after the merge.  As merge transactions do not fire child triggers
                TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.flag.AFFL_doNotRunForContacts, true);

                Database.SaveResult sr = UTIL_DMLService.updateRecord(master, dml);
                if (!sr.isSuccess()) {
                    string strErr = label.npe01.Contact_Merge_Error_Merge_Failed + ' Error: ';
                    for (Database.Error err : sr.getErrors()) {
                        strErr += err.getMessage() + '\n';
                    }
                    Database.rollback(sp);
                    ApexPages.addMessage(new ApexPages.Message(ApexPages.Severity.Error, strErr));
                    return null;
                }

                TDTM_ProcessControl.setRecursionFlag(TDTM_ProcessControl.flag.AFFL_doNotRunForContacts, false);

                CON_ContactMerge.mergeContacts((Contact)master, losers);
                // Update the master with the selected values
                return new PageReference('/' + master.id);
            } catch (Exception e) {
                Database.rollback(sp);
                ERR_Handler.processError(e, ERR_Handler_API.Context.CON);
                ApexPages.addMessage(new ApexPages.Message(ApexPages.Severity.Error, label.npe01.Contact_Merge_Error_Merge_Failed + ' Error: ' + e));
            }
        } else {
            ApexPages.addMessage(new ApexPages.Message(ApexPages.Severity.Error, label.npe01.Contact_Merge_Error_No_Master));
        }

        return null;
    }

    /***************************************************************************************************
    * @description Calculates total number of pages of Duplicate Record Sets
    */
    public Integer getTotalPages() {
        return (Integer)Math.ceil(Decimal.valueOf(stdSetCon.getResultSize())/pageSize);
    }

    /***************************************************************************************************
    * @description Fetches the records to be displayed on first page of Duplicate Record Sets
    */    
    public void firstPage() {
        stdSetCon.first();
        listDuplicateRecordSets = getDuplicateRecordSets();
       
    }
    
    /***************************************************************************************************
    * @description Fetches the records to be displayed on previous page of Duplicate Record Sets
    */ 
    
    public void previousPage() {
        stdSetCon.previous();
        listDuplicateRecordSets = getDuplicateRecordSets();
        
    }   
        
    /***************************************************************************************************
    * @description Fetches the records to be displayed on next page of Duplicate Record Sets
    */
    
    public void nextPage() {
        stdSetCon.next();
        listDuplicateRecordSets = getDuplicateRecordSets();
        
    }
    
    /***************************************************************************************************
    * @description Fetches the records to be displayed on last pages of Duplicate Record Sets
    */ 
    
    public void lastPage() {
        stdSetCon.last();
        listDuplicateRecordSets = getDuplicateRecordSets();
        
    }
    /*******************************************************************************************************
    * @description Wraps a contact together with a checkbox, to allow contact selection.
    */
    public class ContactWrapper {
        /*******************************************************************************************************
        * @description The contact.
        */
        public Contact contactRecord { get; set; }
        /*******************************************************************************************************
        * @description The checkbox.
        */
        public Boolean selected { get; set; }

        /*******************************************************************************************************
        * @description Constructor that initializes instance properties.
        * @c The contact to wrap.
        */
        public ContactWrapper(Contact contactObj) {
            contactRecord = contactObj;
            selected = false;
        }
    }

}
